<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
  <meta name="baidu-site-verification" content="code-kg5UjKJZM2" />
   
  <meta name="keywords" content="活,炼,阿炳" />
   
  <meta name="description" content="shimmerjordan" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    The Framework of Solving Dynamic Programming Problems |  丛烨-shimmerjordan
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'G-Q0DT8B8VJW', 'auto');
ga('send', 'pageview');

</script>



  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?6d06f826e125297d4ce0fa7a1449328e";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


<link rel="alternate" href="/atom.xml" title="丛烨-shimmerjordan" type="application/atom+xml">
</head>

</html>

	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">
	<script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-DynamicProgSolutionFramework"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  The Framework of Solving Dynamic Programming Problems
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/07/31/DPFramwork/" class="article-date">
  <time datetime="2021-07-31T10:38:12.000Z" itemprop="datePublished">2021-07-31</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">3.8k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">24 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p>Dynamic Programming is a problem for many people, but it is also one of the most skillful and interesting strategies. This article gives a partial overview of these problems, plus a framework for solving dynamic programming.</p>
<p><strong>This paper addresses several questions.</strong></p>
<p>What is dynamic programming? </p>
<p>What are the techniques for solving dynamic programming problems?</p>
<p>How can I learn dynamic programming?</p>
<a id="more"></a>

<h1 id="What-is-dynamic-programming"><a href="#What-is-dynamic-programming" class="headerlink" title="What is dynamic programming?"></a>What is dynamic programming?</h1><p>First of all, the general form of a dynamic programming problem is <strong>to find the optimal value</strong>. Dynamic programming is actually an <strong>optimisation method</strong> in operations research, but it is more commonly used in computer problems, such as asking you to find the longest increasing subsequence, the minimum edit distance, and so on.</p>
<p>Since it can be concluded into solving optimal problems, the core of dynamic programming is <strong>exhaustive enumeration</strong>, in which case we are required to  exhaust all possible answers and then find the best value among them.</p>
<p>To begin with, the exhaustion of dynamic programming is a bit special because these problems have ‘<strong>overlapping sub-problems’</strong>, which could be extremely inefficient if they were  violently exhausted, so <strong>‘memos’ or ‘DP tables’</strong> are needed to optimise the exhaustion process and avoid unnecessary computations.</p>
<p>Moreover, dynamic programming problems <strong>must have an ‘optimal sub-structure’</strong> in order to get to the optimal value of the original problem through the optimal value of the sub-problem.</p>
<p>In addition, although the core idea of dynamic programming is to exhaustively find the best value, the problem can be ever-changing. It is not an easy task to exhaust all feasible solutions. Only by listing the <strong>correct ‘state transition equations’</strong> can the exhaustion be correctly exhausted. .</p>
<p>The above-mentioned overlapping sub-problems, optimal sub-structures, and state transition equations are the three elements of dynamic programming. The specific meaning will be explained in detail with examples, but in the actual algorithm problem, <strong>it is the most difficult part to write the state transition equation</strong>. This is why many friends find the problem of dynamic programming difficult. Let me provide a thinking framework that I have researched to help you think about the state transition equation:</p>
<p><strong>Clear base case -&gt; clear ‘state’ -&gt; clear ‘choice’ -&gt; define the meaning of dp array/function.</strong></p>
<p>Follow the above routine, the final result can be set in this framework:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># initialize base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"><span class="comment"># State transition</span></span><br><span class="line"><span class="keyword">for</span> state1 <span class="keyword">in</span> all_values_in_state1:</span><br><span class="line">    <span class="keyword">for</span> state2 <span class="keyword">in</span> all_values_in_state2:</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[state1][state2][...] = optimise(choice1，choice2...)</span><br></pre></td></tr></table></figure>
<p>The following is a detailed explanation of the fundamentals of dynamic programming through the Fibonacci series problem and the rounding up of change problem. The former is mainly to give you an idea of what an overlapping subproblem is (the Fibonacci sequence does not have an optimum, so it is not strictly speaking a dynamic programming problem), and the latter is mainly cited to focus on how to list the state transfer equations.</p>
<h1 id="Ⅰ-Fibonacci-sequence"><a href="#Ⅰ-Fibonacci-sequence" class="headerlink" title="Ⅰ. Fibonacci sequence"></a>Ⅰ. Fibonacci sequence</h1><p>Please don’t mind the simplicity of this example. <strong>Only a simple example will allow you to concentrate fully on the general ideas and techniques behind the algorithm without being baffled by the obscure details.</strong> </p>
<h2 id="1-Violent-recursion"><a href="#1-Violent-recursion" class="headerlink" title="1. Violent recursion"></a>1. Violent recursion</h2><p>The mathematical form of the Fibonacci sequence is recursive, and is written in code like this：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We also know that this is simple and easy to understand, but it is very inefficient. Assuming n = 20, draw the recursive tree:</p>
<center>
  <img style="border-radius: 0.3125em;
  box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
  src="https://cdn.jsdelivr.net/gh/shimmerjordan/pic_bed/blog/DynamicProgSolutionFramework/pic1.png" width='80%'>
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9;
  display: inline-block;
  color: #999;
  padding: 2px;">Recursive tree</div>
</center>

<p>PS: Whenever you encounter a problem that requires recursion, it is a good idea to draw a recursive tree, as this will help you enormously in analysing the complexity of the algorithm and finding the reasons for its inefficiency.</p>
<p>How do I understand this recursive tree? It means that if I want to compute the original problem <code>f(20)</code>, I have to first compute the subproblems <code>f(19)</code> and <code>f(18)</code>, then to compute <code>f(19)</code>, I have to first compute the subproblems <code>f(18)</code> and <code>f(17)</code>, and so on. Finally, when I encounter <code>f(1)</code> or <code>f(2)</code>, whose result is known, so I can return the result directly, and the recursive tree will not grow further down</p>
<p><strong>How is the time complexity of a recursive algorithm calculated? It is the number of sub-problems multiplied by the time it takes to solve a sub-problem.</strong></p>
<p>First, the number of subproblems is calculated, i.e. the total number of nodes in the recursive tree. Obviously the total number of nodes in a binary tree is exponential, so the number of subproblems is $O(2^n)$.</p>
<p>Then the time to solve a subproblem is calculated. In this algorithm, there is no loop and there is only one addition operation, <code>f(n - 1) + f(n - 2)</code>, in $O(1)$.</p>
<p>Therefore, the time complexity of this algorithm is the multiplication of the two, i.e. $O(2^n)$, which is at exponential explosion level.</p>
<p>Looking at the recursive tree, it is clear why the algorithm is inefficient: there are a lot of repeated calculations, for example <code>f(18)</code> is calculated twice, and you can see that this recursive tree, rooted at <code>f(18)</code>, is huge, and calculating it more than once can take a huge amount of time. What is more, more than one node, <code>f(18)</code>, is being repeated, so the algorithm is very inefficient.</p>
<p>This is the first property of the dynamic programming problem: <strong>the overlapping subproblem</strong>. Let’s find a way to solve this problem.</p>
<h2 id="2-Recursive-solution-with-memo"><a href="#2-Recursive-solution-with-memo" class="headerlink" title="2. Recursive solution with memo"></a>2. Recursive solution with memo</h2><p>Once the problem is clear, half of the problem is solved. If the reason for such time-consuming is repeated computation, we can create a ‘memo’, so that each time we have worked out the answer to a sub-problem, we don’t rush to return, but first write it down in the ‘memo’ and then return.</p>
<p>You can also use a hash table (dictionary), and the idea is the same.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Memo fully initialised to 0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// Perform recursion with memo</span></span><br><span class="line">    <span class="keyword">return</span> helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Already calculated</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now, draw the recursive tree so you know exactly what the ‘memo’ does:</p>
<center>
  <img style="border-radius: 0.3125em;
  box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
  src="https://cdn.jsdelivr.net/gh/shimmerjordan/pic_bed/blog/DynamicProgSolutionFramework/pic2.png" width='80%'>
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9;
  display: inline-block;
  color: #999;
  padding: 2px;">Recursive tree</div>
</center>

<p>In fact, the recursive algorithm with ‘memoization’ transforms a recursive tree with a huge amount of redundancy into a recursive graph without redundancy by ‘pruning’ it, greatly reducing the number of sub-problems (i.e. nodes in the recursive graph).</p>
<center>
  <img style="border-radius: 0.3125em;
  box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
  src="https://cdn.jsdelivr.net/gh/shimmerjordan/pic_bed/blog/DynamicProgSolutionFramework/pic3.png" width='70%'>
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9;
  display: inline-block;
  color: #999;
  padding: 2px;">Top-down</div>
</center>

<p><strong>How is the time complexity of a recursive algorithm calculated? It is actually the number of sub-problems multiplied by the time it takes to solve a sub-problem.</strong></p>
<p>The number of subproblems, i.e. the total number of nodes in the graph, is <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>, proportional to the input size <code>n = 20</code>, since there is no redundant computation in this algorithm, so the number of subproblems is $O(n)$.</p>
<p>The time to solve a subproblem, ditto above, without any loops, is $O(1)$.</p>
<p>Therefore, the time complexity of this algorithm is $O(n)$. It is a downscaling blow compared to the brute force algorithm.</p>
<p>Up to this point, the recursive solution with memoization has been as efficient as the iterative dynamic programming solution. In fact, this solution is already similar to iterative dynamic programming, except that this method is called ‘top-down’ and dynamic programming is called ‘bottom-up’.</p>
<p>What does <strong>‘top-down’</strong> mean? Note that the recursive tree (or graph) we just drew extends from the top down, from a larger original problem, such as <code>f(20)</code>, down to the base case of <code>f(1)</code> and <code>f(2)</code>, and then returns the answer layer by layer.</p>
<p>What do you mean by <strong>‘bottom-up’</strong>? On the contrary, we start from the bottom, the simplest and smallest problem, <code>f(1)</code> and <code>f(2)</code>, and work our way up until we get to the answer we want, <code>f(20)</code>. <strong>This is the idea behind dynamic planning, which is why it generally moves away from recursion and instead completes the calculation by loop iteration.</strong></p>
<h2 id="3-Iterative-solution-with-dp-arrays"><a href="#3-Iterative-solution-with-dp-arrays" class="headerlink" title="3. Iterative solution with dp arrays"></a>3. Iterative solution with dp arrays</h2><p>Inspired by the previous step, we can make this ‘memo’ a separate table, called a <strong>DP table</strong>, on which we can do the ‘bottom-up’ projection.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">1</span>] = dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= N; i++)</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center>
  <img style="border-radius: 0.3125em;
  box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
  src="https://cdn.jsdelivr.net/gh/shimmerjordan/pic_bed/blog/DynamicProgSolutionFramework/pic4.png" width='70%'>
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9;
  display: inline-block;
  color: #999;
  padding: 2px;">Process demonstrationn</div>
</center>

<p>The DP table is particularly like the result of the previous ‘pruning’, only in reverse. In fact, the ‘memo’ in the recursive solution with memoization ends up being this DP table, so the two solutions are in fact similar and, in most cases, essentially the same in terms of efficiency.</p>
<p>Here, the term <strong>‘state transfer equation’</strong> is introduced, which is actually the mathematical form that describes the structure of the problem.<br>$$<br>f(n)=<br>\begin{cases}<br>1,\quad n=1,2 \\<br>f(n-1)+f(n-2),\quad n&gt;2<br>\end{cases}<br>$$<br>Why is it called the <strong>‘state transfer equation’</strong>? It’s just to sound high end. You think of <code>f(n)</code> as a state <code>n</code>, which is transferred by adding up states <code>n - 1</code> and <code>n - 2</code>, and that’s called a state transfer, and that’s it.</p>
<p>You will see that all the operations in the above solutions, such as<code> return f(n - 1) + f(n - 2)</code>, <code>dp[i] = dp[i - 1] + dp[i - 2]</code>, and the initialisation of memos or DP tables, are all different manifestations of the equation around which the equation revolves. This shows the importance of listing the ‘state transfer equation’, which is at the core of the problem. And it is easy to see that the state transfer equation actually represents a straightforward violent solution.</p>
<p><strong>Don’t look down on violent solutions. The most difficult part of a dynamic programming problem is to write the violent solution, i.e. the state transfer equation.</strong> As soon as the violent solution is written, the optimisation method is just a memoization or a DP table, and there is no more subtlety.</p>
<p>This example concludes with a detailed optimization. The careful reader will notice that, according to the Fibonacci sequence of state transfer equations, the current state is only related to the previous two states, so it is not necessary to have a DP table that long to store all the states. Therefore, the space complexity can be reduced to $O(1)$ by further optimisation.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> prev = <span class="number">1</span>, curr = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This technique is known as <strong>‘state compression’</strong>. If we find that only a portion of the DP table is needed for each state transfer, then we can try to reduce the size of the DP table by using state compression to record only the necessary data, as in the above example, which is equivalent to reducing the size of the DP table from <code>n</code> to <code>2</code>. We will see examples of this in subsequent chapters on dynamic programming, which generally compress a two-dimensional DP table into one dimension, i.e., reducing the space complexity from $O(n^2)$ to $O(n)$.</p>
<p>One may ask how another important feature of dynamic programming, ‘optimal substructures’, is not covered. It will be covered below. The Fibonacci sequence example is not strictly speaking dynamic programming, since it does not involve finding the optimal value. The above is intended to illustrate the elimination of overlapping subproblems, and to demonstrate the step-by-step process of obtaining the optimal solution. Next, look at the second example, the problem of getting change.</p>
<h1 id="Ⅱ-The-problem-of-getting-change"><a href="#Ⅱ-The-problem-of-getting-change" class="headerlink" title="Ⅱ. The problem of getting change"></a>Ⅱ. The problem of getting change</h1><p>Let’s start with the following question: you are given <code>k</code> coins of denominations <code>c1, c2 ... ck</code>, each with an infinite number of coins. Given an infinite number of each coin, and a total <code>amount</code>, you are asked how many coins <strong>at least</strong> you need to make up this amount, and if this is not possible, the algorithm returns -1. The function signature of the algorithm is as follows</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// coins are the optional coin denominations, and amount is the target amount</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span></span>;</span><br></pre></td></tr></table></figure>
<p>For instance,  <code>k = 3</code> and the denominations are <code>1</code>, <code>2</code> and <code>5</code> and the total <code>amount = 11</code>. Then a minimum of <code>3</code> coins is needed to come up with <code>11 = 5 + 5 + 1</code>.</p>
<p>How do you think the computer should solve this problem? Obviously, by exhausting all the possible ways to make up the coins, and then finding the minimum number of coins needed.</p>
<h2 id="1-Violent-recursion-1"><a href="#1-Violent-recursion-1" class="headerlink" title="1. Violent recursion"></a>1. Violent recursion</h2><p>Firstly, the problem is a dynamic programming problem because it has an ‘optimal sub-structure’. <strong>To be ‘optimally sub-structured’, the sub-problems must be independent of each other.</strong> What do you mean by mutually independent? You won’t want to read a mathematical proof, so I’ll use a visual example to explain.</p>
<p>For example, suppose you take an exam and your results in each subject are independent of each other. Your original problem is to get the highest overall score, so your sub-problem is to get the highest score in language and the highest score in maths …… In order to get the highest score in each subject, you have to get the highest score in the corresponding multiple-choice questions and the highest score in the fill-in-the-blank questions in each subject …… Of course, the end result is that you get a perfect score in each subject, which is the highest overall score.</p>
<p>The correct result is obtained: the highest total score is the total score. Because this process fits into the optimal sub-structure, the sub-problems “highest in each subject” are independent of each other and do not interfere with each other.</p>
<p>However, if you add the condition that your language and maths scores will constrain each other, a high maths score will lower your language score and vice versa. In that case, obviously the highest total score you can get will not reach the total, and you will get the wrong result along the lines of the one you just did. Because the sub-problems are not independent, the language and mathematics scores cannot be optimal at the same time, so the optimal substructure is broken.</p>
<p>Returning to the problem of rounding up the change, why is it consistent with the optimal sub-structure? For example, if you want to find the minimum number of coins for <code>amount = 11</code> (the original problem), and if you know the minimum number of coins to come up with for <code>amount = 10</code> (the subproblem), you simply add one to the answer to the subproblem (and choose a coin of denomination <code>1</code>) to give you the answer to the original problem. Since there is no limit to the number of coins, <strong>the sub-problems are not interlocked and are independent of each other</strong>.</p>
<p>So, since we know that this is a dynamic programming problem, we have to think about <strong>how to list the correct state transfer equation</strong>?</p>
<ol>
<li><p><strong>Determine base case</strong>, which is not difficult. The algorithm returns <code>0</code> when the target <code>amount</code> is <code>0</code>, since it does not need any coins to come up with the target amount.</p>
</li>
<li><p><strong>Determine the ‘state’, i.e. the variables that will change in the original problem and the sub-problem.</strong> Since the number of coins is infinite and the denomination of the coins is given by the question, only the target amount will keep moving closer to the base case, so the only ‘state’ is the target <code>amount</code>.</p>
</li>
<li><p><strong>Determine the ‘choice’, that is, the behaviour that causes the ‘state’ to change.</strong> The reason why the target amount changes is because you are choosing coins, and every time you choose a coin, you are decreasing the target amount. So the face value of all coins is your ‘choice’.</p>
</li>
<li><p><strong>Clarify the definition of the <code>dp</code> function/array.</strong> We are talking about a top-down solution here, so there will be a recursive <code>dp</code> function. Generally speaking, the argument of the function is the amount that will change in the state transfer, that is, the ‘state’ mentioned above; the return value of the function is the amount that the question asks us to calculate. In this case, there is only one state, the ‘target amount’, and we are asked to calculate the minimum number of coins needed to come up with the target amount. So we can define the <code>dp</code> function like this.</p>
</li>
</ol>
<p>Definition of <code>dp(n)</code>: Enter a target amount <code>n</code> and return the minimum number of coins needed to reach the target amount <code>n</code>.</p>
<p>With these key points clear, the pseudocode for the solution can be written as follows.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pseudocode framework</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Definition: To come up with the amount n, at least dp(n) coins are needed</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">n</span>):</span></span><br><span class="line">        <span class="comment"># Make choice: Choose the result that requires the fewest coins</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + dp(n - coin))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="comment"># The final result required by the title is dp(amount)</span></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure>
<p>Based on the pseudocode, we add the base case to get the final answer. Obviously when the target amount is <code>0</code>, the number of coins required is <code>0</code>; when the target amount is less than <code>0</code>, there is no solution and the answer is <code>-1</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">n</span>):</span></span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># to solve the minimal, so initialize to positive infinity</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="comment"># Sub-questions no solution, skipped</span></span><br><span class="line">            <span class="keyword">if</span> subproblem == -<span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure>
<p>At this point, the state transfer equation is in fact complete, and the above algorithm is already a violent solution; the mathematical form of the above code is the state transfer equation.<br>$$<br>dp(n)=<br>\begin{cases}<br>0, \quad n=0 \<br>-1, \quad n&lt;0 \<br>min{dp(n-coin)+1|coin \in coins }, \quad n&gt;0<br>\end{cases}<br>$$<br>At this point, the problem is in fact solved, except for the elimination of the overlapping subproblem, e.g. when <code>amount = 11</code>, <code>coins = &#123;1,2,5&#125;.</code> We draw a recursive tree to see this situation:</p>
<center>
  <img style="border-radius: 0.3125em;
  box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
  src="https://cdn.jsdelivr.net/gh/shimmerjordan/pic_bed/blog/DynamicProgSolutionFramework/pic5.png" width='80%'>
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9;
  display: inline-block;
  color: #999;
  padding: 2px;">recursive tree</div>
</center>

<p>*<em>Time complexity analysis of recursive algorithm: total number of subproblems * time per subproblem costs.*</em></p>
<p>The total number of subproblems is the number of nodes in the recursive tree, which is harder to see and is $O(n^k)$, in short exponential. Each subproblem contains a <code>for</code> loop, which has a complexity of $O(k)$. So the total time complexity is $O(k \cdot n^k)$, which is also exponential level.</p>
<h2 id="2-Recursion-with-memo"><a href="#2-Recursion-with-memo" class="headerlink" title="2. Recursion with memo"></a>2. Recursion with memo</h2><p>Similar to the previous example of the Fibonacci series, the subproblem can be eliminated by memoing, with only minor modifications.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">coins: List[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>):</span></span><br><span class="line">    <span class="comment"># Memo</span></span><br><span class="line">    memo = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span>(<span class="params">n</span>):</span></span><br><span class="line">        <span class="comment"># Check memo to avoid extra counting</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[n]</span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        res = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            subproblem = dp(n - coin)</span><br><span class="line">            <span class="keyword">if</span> subproblem == -<span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">min</span>(res, <span class="number">1</span> + subproblem)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Write into memo</span></span><br><span class="line">        memo[n] = res <span class="keyword">if</span> res != <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>) <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> memo[n]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure>
<p>Obviously ‘memo’ reduces the number of subproblems significantly and eliminates the redundancy of subproblems completely, so the total number of subproblems does not exceed the number of amounts <code>n</code>, i.e. the number of subproblems is $O(n)$. The time to process a subproblem remains the same, $O(k)$, so the total time complexity is $O(kn)$.</p>
<h2 id="3-Iterative-solution-of-dp-arrays"><a href="#3-Iterative-solution-of-dp-arrays" class="headerlink" title="3. Iterative solution of dp arrays"></a>3. Iterative solution of dp arrays</h2><p>Of course, we can also use the bottom-up <strong>dp table</strong>  to eliminate the overlapping sub-problem, and there is no difference between the “state”, “selection” and base case as before. However, the <code>dp</code> function is reflected in the function parameters, while the <code>dp</code> array is reflected in the array index.</p>
<p><strong>The definition of the <code>dp</code> array: when the target amount is <code>i</code>, at least <code>dp[i]</code> coins are needed to round up.</strong></p>
<p>According to the dynamic programming code framework given at the beginning of our article, the solution can be written as follows.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The array size is amount + 1 and the initial value is also amount + 1</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// The outer for loop is iterating over all values of all states</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// The inner for loop is finding the minimum value of all choices</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">// Sub-questions not solved, skipped</span></span><br><span class="line">            <span class="keyword">if</span> (i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (dp[amount] == amount + <span class="number">1</span>) ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center>
  <img style="border-radius: 0.3125em;
  box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
  src="https://cdn.jsdelivr.net/gh/shimmerjordan/pic_bed/blog/DynamicProgSolutionFramework/pic6.png" width='80%'>
  <br>
  <div style="color:orange; border-bottom: 1px solid #d9d9d9;
  display: inline-block;
  color: #999;
  padding: 2px;">Process demonstration</div>
</center>

<p>PS: The reason why the <code>dp</code> array is initialized to <code>amount + 1</code> is because the number of coins that make up the amount can only be equal to the amount at most (all <code>1</code> coins), so initializing to <code>amount + 1</code> is equivalent to initializing to positive infinity, making it easier to take the minimum value later.</p>
<h1 id="Ⅲ-Conclusion"><a href="#Ⅲ-Conclusion" class="headerlink" title="Ⅲ. Conclusion"></a>Ⅲ. Conclusion</h1><p>The first Fibonacci sequence problem explains how to optimise the recursive tree by means of a ‘memo’ or ‘dp table’ approach, and makes it clear that these two approaches are essentially the same, just top-down and bottom-up.</p>
<p>The second problem of scraping together change shows how to process a ‘state transfer equation’, and once the violent recursive solution is written through the state transfer equation, all that remains is to optimise the recursive tree and eliminate overlapping sub-problems.</p>
<p>If you don’t know much about dynamic programming, I applaud you for reading this and believe you have mastered the design of this algorithm.</p>
<p><strong>There is no special technique for a computer to solve a problem. Its only solution is to exhaust all possibilities.</strong> Algorithm design is simply a matter of thinking <strong>‘how to exhaust’</strong> and then pursuing <strong>‘how to exhaust intelligently’</strong>.</p>
<p>Listing the dynamic transfer equations is a solution to the problem of “how to exhaust”. It is difficult because many of them require recursive implementation, and because some of the problems themselves have complex solution spaces that are not so easy to exhaust completely.</p>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://shimmerjordan.site/2021/07/31/DPFramwork/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dynamic-Programming/" rel="tag">Dynamic Programming</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/08/02/LC743-shortestCircuit_mapsStorage/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Five shortest-circuit algorithms &amp; two ways to store maps
          
        </div>
      </a>
    
    
      <a href="/2021/03/16/vuexStoreDispatchAndCommit/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">The difference between this.\$store.dispatch() and this.\$store.commit() in vuex</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "StYfTMDp78X0EltFR16ve2q5-gzGzoHsz",
    app_key: "G4RPxRpXG6RwdfpnJefOSnyy",
    path: window.location.pathname,
    avatar: "wavatar",
    placeholder: "ヾﾉ≧∀≦)o来啊，快活啊!",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
   
<!-- minivaline评论 -->
<div id="mvcomments-box">
  <div id="mvcomments"></div>
</div>
<script src="https://cdn.jsdelivr.net/npm/minivaline@latest"></script>
<script>
    new MiniValine(Object.assign({"enable":true,"mode":"DesertsP","placeholder":"Write a Comment","math":true,"md":true,"enableQQ":true,"NoRecordIP":false,"visitor":true,"maxNest":6,"pageSize":6,"adminEmailMd5":"de8a7aa53d07e6b6bceb45c64027763d","tagMeta":["管理员","小伙伴","访客"],"master":["de8a7aa53d07e6b6bceb45c64027763d"],"friends":["b5bd5d836c7a0091aa8473e79ed4c25e","adb7d1cd192658a55c0ad22a3309cecf","3ce1e6c77b4910f1871106cb30dc62b0","cfce8dc43725cc14ffcd9fb4892d5bfc"],"lang":null,"emoticonUrl":["https://cdn.jsdelivr.net/npm/alus@latest","https://cdn.jsdelivr.net/gh/MiniValine/qq@latest","https://cdn.jsdelivr.net/gh/MiniValine/Bilibilis@latest","https://cdn.jsdelivr.net/gh/MiniValine/tieba@latest","https://cdn.jsdelivr.net/gh/MiniValine/twemoji@latest","https://cdn.jsdelivr.net/gh/MiniValine/weibo@latest"]}, {
	  el: '#mvcomments',
    }));
  const infoEle = document.querySelector('#mvcomments .info');
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
      infoEle.childNodes.forEach(function (item) {
          item.parentNode.removeChild(item);
      });
  }
</script>
<style>
	#mvcomments-box {
		padding: 5px 30px;
	}
	@media screen and (max-width: 800px) {
		#mvcomments-box {
		  padding: 5px 0px;
		}
	}
	.darkmode .MiniValine *{
		color: #f1f1f1!important;
	}
	.darkmode .commentTrigger{
		background-color: #403e3e !important;
	  }
	.darkmode .MiniValine .vpage .more{
		background: #21232F
	}
	.darkmode img{
		filter: brightness(30%)
	}
	.darkmode .MiniValine .vlist .vcard .vcomment-body .text-wrapper .vcomment.expand:before{
		background: linear-gradient(180deg, rgba(246,246,246,0), rgba(0,0,0,0.9))
	}
	.darkmode .MiniValine .vlist .vcard .vcomment-body .text-wrapper .vcomment.expand:after{
		background: rgba(0,0,0,0.9)
	}
	.darkmode .MiniValine .vlist .vcard .vcomment-body .text-wrapper .vcomment pre{
		background: #282c34
		border: 1px solid #282c34
	}
	.darkmode .MiniValine .vinputs-area .textarea-wrapper textarea{
		color: #000;
	}
	.darkmode .MiniValine .vinputs-area .auth-section .input-wrapper input{
		color: #000;
	}
	.darkmode .MiniValine .vinputs-area .vextra-area .vsmile-icons{
		background: transparent;
	}
	.darkmode .MiniValine .vinputs-wrap{
		border-color: #b2b2b5;
	}
	.darkmode .MiniValine .vinputs-wrap:hover{
		border: 1px dashed #2196f3;
	}
	.darkmode .MiniValine .vinputs-area .auth-section .input-wrapper{
		border-bottom: 1px dashed #b2b2b5;
	}
	.darkmode .MiniValine .vinputs-area .auth-section .input-wrapper:hover{
		border-bottom: 1px dashed #2196f3;
	}
	.darkmode .MiniValine .vbtn{
		background-color: transparent!important;
	}
	.darkmode .MiniValine .vbtn:hover{
		border: 1px dashed #2196f3;
	}
</style>

    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2019-2023
        <i class="ri-heart-fill heart_icon"></i> 鞠桥丹-QIAODAN JU
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s4.cnzz.com/z_stat.php?id=1279035150&amp;web_id=1279035150'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="丛烨-shimmerjordan"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Catalogue</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">Tags</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E9%9A%8F%E7%AC%94/">Essay</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">Friends</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2020/01/18/about">About</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯蓝莓汁吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->


<script src="/js/clickLove.js"></script>


<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
  </div>
</body>

</html>